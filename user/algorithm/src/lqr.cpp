/**
 *******************************************************************************
 * @file      : lqr.cpp
 * @brief     :
 * @history   :
 *  Version     Date            Author          Note
 *  V0.9.0      yyyy-mm-dd      <author>        1. <note>
 *******************************************************************************
 * @attention :
 *******************************************************************************
 *  Copyright (c) 2024 Reborn Team, USTB.
 *  All Rights Reserved.
 *******************************************************************************
 */
 /* Includes ------------------------------------------------------------------*/
#include "lqr.h"

#include "stdint.h"
/* Private macro -------------------------------------------------------------*/
/* Private constants ---------------------------------------------------------*/
/* Private types -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

//K的三次拟合系数
const float k[12][4] = {
  {-449.290430f, 481.767569f, -199.930640f, -10.926357f},
  {-98.412882f, 95.640043f, -33.624468f, -3.009310f},
  {-74.171076f, 80.642962f, -31.395684f, -6.077675f},
  {-23.046660f, 28.487750f, -10.961737f, -10.468330f},
  {-211.029379f, 277.178590f, -137.938507f, 30.484353f},
  {-78.393427f, 109.544531f, -56.254173f, 12.358325f},
  {605.884519f, -349.728894f, -8.163624f, 29.826761f},
  {-8.351990f, 57.916844f, -46.707682f, 11.970346f},
  {136.019427f, -57.003702f, -19.435696f, 10.847325f},
  {8.167834f, 71.585755f, -64.952482f, 16.503337f},
  {840.422821f, -839.137851f, 294.848687f, 20.222046f},
  {355.859373f, -353.246074f, 123.229484f, 12.629003f}
};

/* External variables --------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/

void Lqr::Calc() {
  float lsqr = leg_len_ * leg_len_;
  float lcub = leg_len_ * leg_len_ * leg_len_;
  //计算当前腿长下的lqrK增益矩阵
  for (uint8_t i = 0; i < 2; ++i) {
    uint8_t j = i * 6;
    T_K_[i][0] =
      (k[j + 0][0] * lcub + k[j + 0][1] * lsqr + k[j + 0][2] * leg_len_ + k[j + 0][3]) * -theta_;
    T_K_[i][1] =
      (k[j + 1][0] * lcub + k[j + 1][1] * lsqr + k[j + 1][2] * leg_len_ + k[j + 1][3]) * -w_theta_;
    T_K_[i][2] =
      (k[j + 2][0] * lcub + k[j + 2][1] * lsqr + k[j + 2][2] * leg_len_ + k[j + 2][3]) * -dist_;
    T_K_[i][3] =
      (k[j + 3][0] * lcub + k[j + 3][1] * lsqr + k[j + 3][2] * leg_len_ + k[j + 3][3]) *
      (target_speed_ - speed_);
    T_K_[i][4] =
      (k[j + 4][0] * lcub + k[j + 4][1] * lsqr + k[j + 4][2] * leg_len_ + k[j + 4][3]) * -phi_;
    T_K_[i][5] =
      (k[j + 5][0] * lcub + k[j + 5][1] * lsqr + k[j + 5][2] * leg_len_ + k[j + 5][3]) * -w_phi_;
  }
  //离地时，仅对髋关节计算theta和theta_dot
  if (F_N_ < 20.0f) {
    for (uint8_t i = 0; i < 6; ++i) {
      T_K_[0][i] = 0.0f;
    };
    T_K_[1][2] = T_K_[1][3] = T_K_[1][4] = T_K_[1][5] = 0.0f;
  }
  //正常情况，计算T和Tp
  for (uint8_t i = 0; i < 2; ++i) {
    T_[i] = T_K_[i][0] + T_K_[i][1] + T_K_[i][2] + T_K_[i][3] + T_K_[i][4] +
      T_K_[i][5];
  }
}